/*!
 * Copyright 2014 Digital Services, University of Cambridge Licensed
 * under the Educational Community License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var csv = require('csv');
var fs = require('fs');

var AuthzUtil = require('oae-authz/lib/util');
var log = require('oae-logger').logger('oae-departments');
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-util/lib/validator').Validator;

var Department = require('./models').Department;
var DepartmentsConstants = require('./constants').DepartmentsConstants;

//////////////////
//  PUBLIC API  //
//////////////////

/**
 * ### Events
 *
 * The `DepartmentsAPI`, as enumerated in `DepartmentsConstants.events`, emits the following events:
 *
 * * `createdDepartment(ctx, department)`: A new department item was created. The `ctx` and the `department` object that was created are both provided.
 */
var DepartmentsAPI = module.exports = new events.EventEmitter();

/**
 * Import a collection of departments
 *
 * The CSV file should be constructed in a way that the first `value` contains the id of the department.
 * The second `value` contains the name of the department.
 *
 *  * Example of CSV rows:
 *  *
 *  * 1,Department of Biology
 *  * 2,Department of Physics
 *  * 3,Department of Zoology
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         tenantAlias             The tenant alias for the department
 * @param  {Object}         departmentsCSV          File object representing the uploaded CSV file as returned by Express
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 */
var importDepartments = module.exports.importDepartments = function(ctx, tenantAlias, departmentsCSV, callback) {

    /*!
     * Function that is executed when the importing process is finished
     *
     * @param  {Object}     [err]       The thrown error, if any
     * @api private
     */
    var cleanCallback = function(err) {
        _cleanUpCSVFile(departmentsCSV, function() {
            return callback(err);
        });
    };

    // Return an error if the current user is not allowed to import departments
    if (!_canEnterData(ctx)) {
        cleanCallback({'code': 401, 'msg': 'Only authorized administrators are allowed to import departments'});
    }

    // Get the tenant details
    var tenant = TenantsAPI.getTenant(tenantAlias);

    // Validate the parameters
    var validator = new Validator();
    validator.check(tenant, {'code': 400, 'msg': 'An existing tenant alias must be provided'}).notNull();
    validator.check(departmentsCSV, {'code': 400, 'msg': 'A CSV file must be provided'}).notNull();
    if (departmentsCSV) {
        validator.check(departmentsCSV.size, {'code': 400, 'msg': 'Missing size on the CSV file'}).notEmpty();
        validator.check(departmentsCSV.size, {'code': 400, 'msg': 'Invalid size on the CSV file'}).isInt();
        validator.check(departmentsCSV.size, {'code': 400, 'msg': 'Empty CSV files cannot be uploaded'}).min(0);
        validator.check(departmentsCSV.name, {'code': 400, 'msg': 'Missing name on the CSV file'}).notEmpty();
    }
    if (validator.hasErrors()) {
        log().error(validator.getFirstError(), 'Error while importing departments from .CSV file');
        return cleanCallback(validator.getFirstError());
    }

    // Will contain an entry for each department in the CSV file
    var departmentsData = [];

    // The CSV module works with streams, so get a readable stream to the uploaded CSV file
    var csvData = fs.createReadStream(departmentsCSV.path);

    // Pipe the stream to a CSV parser and keep track of the department records
    var parser = csv.parse();
    csvData.pipe(parser);
    parser.on('readable', function() {
        var department = parser.read();
        while (department) {
            departmentsData.push(department);
            department = parser.read();
        }
    });

    parser.on('finish', function() {
        var departmentsCollection = _.map(departmentsData, function(department) {
            return new Department(_generateDepartmentId(tenantAlias, department[0]), tenantAlias, department[1]);
        });

        // Validate each department
        _.each(departmentsCollection, function(department) {
            validator.check(department.id, {'code': 400, 'msg': 'An invalid ID was passed in for department: ' + department.displayName}).notEmpty();
            validator.check(department.id, {'code': 400, 'msg': 'The generated id for "' + department.displayName + '" is not wellformed'}).isValidId();
            validator.check(department.tenantAlias, {'code': 400, 'msg': 'An invalid tenantAlias was passed in for department: ' + department.displayName}).notEmpty();
            validator.check(department.displayName, {'code': 400, 'msg': 'An invalid displayName was passed in for department: ' + department.id}).notEmpty();
        });
        if (validator.hasErrors()) {
            log().error(validator.getFirstError(), 'Error while importing departments from .CSV file');
            return cleanCallback(validator.getFirstError());
        }

        // Ingest the departments
        _ingestDepartments(ctx, departmentsCollection);
        return cleanCallback(null);

    // Remove the CSV file when an error occurred
    }).on('error', function(err) {
        return cleanCallback({'code': 500, 'msg': err.message});
    });
};

//////////////////////////
//  INTERNAL FUNCTIONS  //
//////////////////////////

/**
 * Function that ingests departments into ElasticSearch
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Department[]}   departmentsCollection   Collection of departments
 */
var _ingestDepartments = function(ctx, departmentsCollection) {
    log().info('Start importing departments from CSV');
    _.each(departmentsCollection, function(department) {
        DepartmentsAPI.emit(DepartmentsConstants.events.CREATED_DEPARTMENT, ctx, department);
    });
};

/**
 * Remove an uploaded departments CSV file
 * TODO: Move this out into a utility as this functionality is needed in a number of places
 *
 * @param  {Object}         departmentsCSV          File object representing the uploaded CSV file as returned by Express
 * @param  {Function}       callback                Standard callback function
 * @api private
 */
var _cleanUpCSVFile = function(departmentsCSV, callback) {
    if (departmentsCSV && departmentsCSV.path) {
        fs.exists(departmentsCSV.path, function(exists) {
            if (exists) {
                fs.unlink(departmentsCSV.path, function(err) {
                    if (err) {
                        log().warn({'err': err, 'file': departmentsCSV}, 'Could not remove the departments import CSV file');
                    }
                    return callback();
                });
            } else {
                return callback();
            }
        });
    } else {
        return callback();
    }
};

/**
 * Generate a department ID
 *
 * @param  {String}         tenantAlias             The tenant alias for the department
 * @param  {String}         id                      The external identifier of the department
 * @return {String}                                 The generated department's ID
 * @api private
 */
var _generateDepartmentId = function(tenantAlias, id) {
    return AuthzUtil.toId('d', tenantAlias, id);
};

/////////////////////
//  AUTHORIZATION  //
/////////////////////

/**
 * Verifies that the current user is allowed to import departments from a CSV file
 *
 * @param  {Context}        ctx             Standard context object containing the current user and the current tenant
 * @return {Boolean}                        Whether or not the user is allowed to enter data
 */
var _canEnterData = function(ctx) {
    if (!ctx.user()) {
        return false;
    }

    // Tenant admins are only allowed to import departments for their own tenant
    if (ctx.user().isAdmin(ctx.tenant().alias)) {
        return true;
    }

    // Global admins are always allowed to import departments
    if (ctx.user().isGlobalAdmin()) {
        return true;
    }

    // Deny if none of the above applies
    return false;
};
