/*!
 * Copyright 2014 Digital Services, University of Cambridge Licensed
 * under the Educational Community License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var csv = require('csv');
var events = require('events');
var fs = require('fs');

var log = require('oae-logger').logger('oae-journals');
var Validator = require('oae-util/lib/validator').Validator;

var Journal = require('./model').Journal;
var JournalsConstants = require('./constants').JournalsConstants;

//////////////////
//  PUBLIC API  //
//////////////////

/**
 * ### Events
 *
 * The `JournalsAPI`, as enumerated in `JournalsConstants.events`, emits the following events:
 *
 * * `createdJournal(ctx, journal)`: A new journal item was created. The `ctx` and the `journal` object that was created are both provided.
 */
var JournalsAPI = module.exports = new events.EventEmitter();

/**
 * Import a collection of journals
 *
 * The CSV file should be constructed in a way that the first `value` contains the name of the journal.
 * The second and third `value` contain the "print ISSN" and/or the "electronic ISSN".
 *
 *  * Example of CSV rows:
 *  *
 *  * AAOHN Journal,0891-0162
 *  * AAPS PharmSciTech,1530-9932,1522-1059
 *  * Abdominal Imaging,0942-8925,1432-0509
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Object}         journalsCSV             File object representing the uploaded CSV file as returned by Express
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 */
var importJournals = module.exports.importJournals = function(ctx, journalsCSV, callback) {

    /*!
     * Function that is executed when the importing process is finished
     *
     * @param  {Object}     [err]       The thrown error, if any
     * @api private
     */
    var cleanCallback = function(err) {
        _cleanUpCSVFile(journalsCSV, function() {
            return callback(err);
        });
    };

    // Return an error if the user is not allowed to import journals
    if (!_canEnterData(ctx)) {
        cleanCallback({'code': 401, 'msg': 'Only global administrators are allowed to import journals'});
    }

    // Validate the journals CSV file
    var validator = new Validator();
    validator.check(journalsCSV, {'code': 400, 'msg': 'A CSV file must be provided'}).notNull();
    if (journalsCSV) {
        validator.check(journalsCSV.size, {'code': 400, 'msg': 'Missing size on the CSV file'}).notEmpty();
        validator.check(journalsCSV.size, {'code': 400, 'msg': 'Invalid size on the CSV file'}).isInt();
        validator.check(journalsCSV.size, {'code': 400, 'msg': 'Empty CSV files cannot be uploaded'}).min(0);
        validator.check(journalsCSV.name, {'code': 400, 'msg': 'Missing name on the CSV file'}).notEmpty();
    }
    if (validator.hasErrors()) {
        log().error(validator.getFirstError(), 'Error while importing journals from .CSV file');
        return cleanCallback(validator.getFirstError());
    }


    // Will contain an entry for each journal in the CSV file
    var journalsData = [];

    // The CSV module works with streams, so get a readable stream to the uploaded CSV file
    var input = fs.createReadStream(journalsCSV.path);

    // Pipe the stream to a CSV parser and keep track of the journal records
    var parser = csv.parse();
    input.pipe(parser);
    parser.on('readable', function() {
        var user = parser.read();
        while (user) {
            journalsData.push(user);
            user = parser.read();
        }
    });
    parser.on('finish', function() {

        // Concatenate the print- and electronic ISSN's for each journal
        var journalsCollection = [];
        _.each(journalsData, function(journal) {

            // Only add the journal to the collection if a valid title and ISSN has been provided
            if (journal[0] && (_isValidISSN(journal[1]) || _isValidISSN(journal[2]))) {
                var journalId = _concatJournalIds(journal[1], journal[2]);
                journalsCollection.push(new Journal(journalId, journal[0]));
            } else {
                log().warn({'journal': journal}, 'This journal entry contained invalid input, ignoring');
            }
        });

        // Validate each journal
        validator.check(journalsCollection.length, {'code': 400, 'msg': 'At least one journal should be imported'}).min(1);
        if (validator.hasErrors()) {
            log().error(validator.getFirstError(), 'Error while importing journals from .CSV file');
            return cleanCallback(validator.getFirstError());
        }

        // Ingest the journals
        _ingestJournals(ctx, journalsCollection);
        return cleanCallback(null);

    // Remove the CSV file when an error occurred
    }).on('error', function(err) {
        return cleanCallback({'code': 500, 'msg': err.message});
    });
};

//////////////////////////
//  INTERNAL FUNCTIONS  //
//////////////////////////

/**
 * Function that cleans up and concatinates the journal's ISSN's
 *
 * @param  {String}         printISSN               The print ISSN of the journal
 * @param  {String}         electronicISSN          The electronic ISSN of the journal
 * @return {String}                                 The concatinated ISSN's
 * @api private
 */
var _concatJournalIds = function(printISSN, electronicISSN) {

    /*!
     * Internal function that cleans up an ISSN
     *
     *  * Some ISSN's can have multiple values:
     *  * e.g.: "1234-1234, 1234-1234"
     *  *
     *  * Since commas would cause conflicts in ElasticSearch, we need to strip them out.
     *  * The expected format for the generated ID is: "1234-1234-1234-1234"
     *
     * @param  {String}     ISSN    The ISSN that needs reformatting
     * @return {String}             The reformatted ISSN
     * @api private
     */
    var cleanUpISSN = function(ISSN) {
        var ids = ISSN.trim().split(',');
        return _.chain(ids).map(function(id) { return id.trim().replace(/\W+/g, '_'); }).compact().join('_').value();
    };

    // Clean up the ISSN's
    printISSN = cleanUpISSN(printISSN);
    electronicISSN = cleanUpISSN(electronicISSN);


    //console.log(_.compact([printISSN, electronicISSN]).join('-'));

    // Return the ISSN's as a single string
    return _.compact([printISSN, electronicISSN]).join('-');
};

/**
 * Function that ingests journals into ElasticSearch
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Journal[]}      journalsCollection      Collection of journals
 */
var _ingestJournals = function(ctx, journalsCollection) {
    log().info('Starting journal import from CSV');
    _.each(journalsCollection, function(journal) {
        JournalsAPI.emit(JournalsConstants.events.CREATED_JOURNAL, ctx, journal);
    });
};

/**
 * Remove an uploaded journals CSV file
 * TODO: Move this out into a utility as this functionality is needed in a number of places
 *
 * @param  {Object}         journalsCSV             File object representing the uploaded CSV file as returned by Express
 * @param  {Function}       callback                Standard callback function
 * @api private
 */
var _cleanUpCSVFile = function(journalsCSV, callback) {
    if (journalsCSV && journalsCSV.path) {
        fs.exists(journalsCSV.path, function(exists) {
            if (exists) {
                fs.unlink(journalsCSV.path, function(err) {
                    if (err) {
                        log().warn({'err': err, 'file': journalsCSV}, 'Could not remove the journals import CSV file');
                    }
                    callback();
                });
            } else {
                callback();
            }
        });
    } else {
        callback();
    }
};

/**
 * Check if a valid ISSN has been provided
 *
 * @param  {String}     ISSN    The provided ISSN
 * @return {Boolean}            Whether the ISSN is valid or not
 */
var _isValidISSN = function(ISSN) {
    return (ISSN !== undefined && ISSN !== null && ISSN !== '');
};

/////////////////////
//  AUTHORIZATION  //
/////////////////////

/**
 * Verify that the current user is a global admin
 *
 * @param  {Context}        ctx             Standard context object containing the current user and the current tenant
 * @return {Boolean}                        Whether or not the user is allowed to enter data
 */
var _canEnterData = function(ctx) {
    return (ctx.user() && ctx.user().isGlobalAdmin);
};
