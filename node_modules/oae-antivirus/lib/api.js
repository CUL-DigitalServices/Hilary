/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var events = require('events');
var fs = require('fs');
var util = require('util');
var watch = require('watch');
var watcher = require('watchr');

var ContentDAO = require('oae-content/lib/internal/dao');
var log = require('oae-logger').logger('oae-antivirus');

var AntiVirusConstants = require('./constants').AntiVirusConstants;

// The cached configurations
var config = null;

// The instance of the Watcher object
var _watcherInstance = null;

/**
 * This module takes care of monitoring and handling uploaded corrupt files.
 *
 * A periodic scan (Puppet cronjob) is performed by ClamAV, which lists the corrupt files in a log file.
 * Node.js picks up changes in the log file and marks the specific files as 'dangerous'.
 *
 * ClamScan documentation:
 * @see http://linux.die.net/man/1/clamscan
 *
 *  * To perform a scan we execute:
 *  *
 *  *   $ clamscan
 *  *   {localStorageDirectory}             The directory we want to monitor
 *  *   -r                                  Also scan subdirectories [--recursive]
 *  *   -i                                  Only list infected files in the log file [--infected]
 *  *   -l {logFile}                        The location of the log file [--log=FILE]
 *  *   --no-summary                        Do not include summary at the end of scanning
 *  *   --move={corruptFilesDirectory}      The folder we want to move corrupt files to
 *  *
 *  *   E.g.: $clamscan /mnt/files -r -i -l /var/log/clamav.log --no-summary --move=/mnt/corrupt_files
 *  *
 *  * ClamAV lists all the currupt files following this pattern:
 *  *
 *  *   {localStorageDirectory}/c/{tenantAlias}/lk/bW/_j/Wt/lkbW_jWtGC/rev-{tenantAlias}-e1fbuoWtfC/fileA.com.txt fileA.com.txt FOUND
 *  *   {localStorageDirectory}/c/{tenantAlias}/xk/7V/6H/Mt/xk7V6HMtMA/rev-{tenantAlias}-lJ4VpSGtfC/fileB.com.txt fileB.com.txt FOUND
 *  *
 *  * NOTE:
 *  * Since ClamAV writes every corrupt file separately to the log file, we will only read the 'final' log file, to prevent dispatching an event for every update.
 *  * The 'final' log file will be created when the ClamAV process exits.
 */

//////////////////
//  PUBLIC API  //
//////////////////

/**
 * ### Events
 *
 * The `AntiVirusAPI`, as enumerated in `AntiVirusConstants.events`, emits the following events:
 *
 * * `create()`
 * * `delete()`
 * * `error(err)`
 * * `update()`
 * * `watching()`
 */
var AntiVirusAPI = module.exports = new events.EventEmitter();

/**
 * Initialize the AntiVirus API
 *
 * @param  {Object}    _config          ClamAV configuration
 * @param  {Function}  callback         Standard callback function
 */
var init = module.exports.init = function(_config, callback) {

    // Store the configuration locally
    config = _config;

    // Only watch the log file when this feature is enabled for the tenant
    if (config.enabled) {
        startMonitoring(config);
    }

    return callback();
};

/**
 * Start monitoring the directory that holds the ClamAV log file
 *
 * @param  {Object}    _config              ClamAV configuration
 * @param  {Function}  [callback]           Standard callback function
 * @param  {Object}    [callback.error]     Object containing error code and error message
 */
var startMonitoring = module.exports.startMonitoring = function(_config, callback) {
    callback = callback || function() {};

    // Store the configuration locally
    config = _config;

    // Start monitoring the directory that stores the ClamAV log file
    watcher.watch({
        'path': config.logDirectory,
        'listeners': {
            'change': onChangeHandler,
            'error': onErrorHandler,
            'watching': onWatchHandler
        }
    });
};

/**
 * Stop monitoring the directory that holds the ClamAV log file
 */
var stopMonitoring = module.exports.stopMonitoring = function() {
    try {
        _watcherInstance.close('delete');
        return AntiVirusAPI.emit(AntiVirusConstants.events.STOP);

    } catch(err) {
        log().error({'code': 400, 'msg': err}, 'Error while stopping the monitoring of the log files');
        AntiVirusAPI.emit(AntiVirusConstants.events.ERROR, {'code': 400, 'msg': err});
    }
};

//////////////////////////
//  INTERNAL FUNCTIONS  //
//////////////////////////

/**
 * Function that is executed when a file change occurred
 *
 * @param  {String}     changeType          The event type that occurred (e.g. 'create', 'update', 'delete')
 * @param  {String}     filePath            The full path to the file
 * @param  {Object}     [fileCurrentStat]   The current status of the file. (not availble on 'create')
 * @param  {Object}     [filePreviousStat]  The previous status of the file. (not available on 'delete')
 * @api private
 */
var onChangeHandler = function(changeType, filePath, fileCurrentStat, filePreviousStat) {

    // Only handle created files
    if (changeType === 'create') {

        // Read the log file
        fs.readFile(filePath, 'utf-8', function(err, data) {
            if (err) {
                log().error({'code': 400, 'msg': err}, 'An error occurred whilst reading the log file');
                return AntiVirusAPI.emits(AntiVirusConstants.emits.ERROR, {'code': 400, 'msg': err});
            }

            // Transform the plain text to an array of filenames
            data = data.split(/\r?\n/);
            data = _.chain(data)
                .compact()
                .map(function(line) { return line.trim(); })
                .filter(function(line) { return line.indexOf('FOUND') > -1; })
                .value();

            // Loop each line and get the file's location
            var revisionIds = [];
            _.each(data, function(line) {
                revisionIds.push(_getRevisionId(line));
            });

            if (revisionIds.length) {

                // Fetch the revision profiles
                ContentDAO.Revisions.getMultipleRevisions(revisionIds, null, function(err, revisions) {
                    if (err) {
                        log().error({'code': err.code, 'msg': 'Error while fetching revisions for corrupt files', 'revisionIds': revisionIds}, 'Error while fetching revisions of currupt files');
                        return AntiVirusAPI.emit(AntiVirusConstants.events.FAILED, {'code': err.code, 'msg': 'Error while fetching revisions for corrupt files', 'revisionIds': revisionIds});
                    }

                    // Fetch the content id's
                    var contentIds = _.pluck(revisions, 'contentId');
                    ContentDAO.Content.getMultipleContentItems(contentIds, null, function(err, contentItems) {
                        if (err) {
                            log().error({'code': err.code, 'msg': 'Error while fetching content items for corrupt files', 'revisionIds': revisionIds}, 'Error while fetching content items currupt files');
                            return AntiVirusAPI.emit(AntiVirusConstants.events.FAILED, {'code': err.code, 'msg': 'Error while fetching content items for corrupt files', 'revisionIds': revisionIds});
                        }

                        /*!
                         * Update the content items
                         */
                        var _updateContentItems = function() {
                            if (!contentItems.length) {
                                return AntiVirusAPI.emit(AntiVirusConstants.events.CREATE);
                            }

                            // Update the content item
                            var contentItem = contentItems.pop();
                            var updates = {'displayName': util.format('[CORRUPT] %s', contentItem.displayName)};
                            ContentDAO.Content.updateContent(contentItem, updates, true, function(err, updatedContentItem) {
                                if (err) {
                                    log().error({'code': err.code, 'msg': 'Error while updating content item'}, 'Error while updating content item');
                                }

                                // Continue updating the content items
                                _updateContentItems();
                            });
                        };

                        // Start updating the content items
                        _updateContentItems();
                    });
                });
            }
        });
    }
};

/**
 * Function that is executed when an error occurred
 *
 * @param  {String}     error               The thrown error, if any
 * @api private
 */
var onErrorHandler = function(error) {
    log().error({'code': 400}, 'An error occurred whilst reading the log file');
    AntiVirusAPI.emit(AntiVirusConstants.events.ERROR, error);
};

/**
 * Function that is executed when a directory is being monitored
 *
 * @param  {String}     error               The thrown error, if any
 * @param  {Object}     watcherInstance    Object representing the watcher
 * @param  {Boolean}    isWatching          Whether or not monitoring the directory is successful
 */
var onWatchHandler = function(error, watcherInstance, isWatching) {
    if (error) {
        log().error({'code': 400, 'msg': err}, util.format('Error while attempting to monitor: %s', watcherInstance.path));
        return AntiVirusAPI.emit(AntiVirusConstants.events.ERROR, {'code': 400, 'msg': err});
    } else {
        _watcherInstance = watcherInstance;
        log().info(util.format('Successfully started monitoring: %s', watcherInstance.path));
        return AntiVirusAPI.emit(AntiVirusConstants.events.START);
    }
};

/**
 * Returns the revision ID from a given path
 *
 *  * The specified path will something like:
 *  * {localStorageDirectory}/c/{tenantAlias}/lk/bW/_j/Wt/lkbW_jWtGC/rev-{tenantAlias}-e1fbuoWtfC/fileA.com.txt
 *  *
 *  * We need to fetch the revisionId from the path, which will - in this case - be: rev:{tenantAlias}:e1fbuoWtfC
 *
 * @param  {String}     path    The given path where the revision ID needs to be fetched from
 * @return {String}             The revision ID fetched from the path
 * @api private
 */
var _getRevisionId = function(path) {

    // First filter the path out of the string
    path = path.split(' ')[0];
    path = path.split('/').reverse()[1];

    // First split the string on its dashes
    path = path.split('-');

    // Put the string back together if the array has 3 elements (e.g. when the revision id was rev-alias-0123456789)
    if (path.length === 3) {
        return path.join(':');

    // Only join the first three elements with a colon if the array has more than 3 children (e.g. when revision id was rev-alias-0123-45678)
    } else {
        var lastPart = path.splice(3, (path.length - 3)).join('-');
        if (_.isArray(lastPart)) {
            lastPart = lastPart.join('-');
        }

        return String(path.join(':') + '-' + lastPart);
    }
};
