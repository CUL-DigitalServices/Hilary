/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');
var util = require('util');

var ActivityAPI = require('oae-activity');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var AuthzUtil = require('oae-authz/lib/util');
var ConfigAPI = require('oae-config');
var Context = require('oae-context').Context;
var log = require('oae-logger').logger('oae-tickets');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PublicationsEmitter = require('oae-publications/lib/internal/emitter');
var TenantsAPI = require('oae-tenants');
var Validator = require('./validator').Validator;

var TicketsConfig = ConfigAPI.config('oae-tickets');
var TicketsConstants = require('./constants').TicketsConstants;
var TicketsDAO = require('./internal/dao');
var TicketsEmitter = require('./internal/emitter');

/**
 * Initializes the Tickets module.
 * This will listen for OAE activities and will create a new ticket when a new resource was uploaded
 *
 * @param  {Object}    config       Configuration for the TinCan API module
 * @param  {Function}  callback     Standard callback function
 */
var initializeTickets = module.exports.initializeTickets = function(callback) {

    /*!
     * Listen to the created publication event
     *
     *  * result        The name of the dispatched event
     *  * ctx           The current context
     *  * publication   The created publication
     */
    PublicationsAPI.on(PublicationsConstants.ingestionResult.CREATED, function(result, ctx, publication) {

        // Check if the Tickets module is enabled for the tenant
        if (TicketsConfig.getValue(ctx.tenant().alias, 'general', 'enabled')) {

            var opts = {
                'creatorId': ctx.user().id,
                'publicationId': publication.id,
                'tenantAlias': ctx.tenant().alias
            };

            createTicket(ctx, opts, function(err, ticket) {
                if (err) {
                    TicketsEmitter.emit(TicketsConstants.events.CREATED_TICKET, err);
                }

                TicketsEmitter.emit(TicketsConstants.events.CREATED_TICKET, null, ticket);
            });
        }
    });

    callback();
};

/**
 * Generates a new ticket ID.
 *
 * @param  {String}     tenantAlias     The tenant alias for the ticket
 * @return {String}                     The new ticket ID
 * @api private
 */
var _generateTicketId = function(tenantAlias) {
    return AuthzUtil.toId('t', tenantAlias, ShortId.generate());
};

/**
 * Create a new ticket
 *
 * @param  {Object}     ctx                     The current context
 * @param  {Object}     opts                    Object containing properties for the ticket that needs to be created
 * @param  {String}     opts.creatorId          The id of the user that created the ticket
 * @param  {String}     opts.publicationId      The id of the publication that was created and linked to the ticket
 * @param  {String}     opts.tenantAlias        The tenant alias
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Error object containing error code and error message
 * @param  {Ticket}     callback.ticket         Object representing the created ticket
 * @api private
 */
var createTicket = module.exports.createTicket = function(ctx, opts, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Only authorized admins are allowed to request tickets'});
    }

    // Check if the Tickets module is enabled for the tenant
    if (!TicketsConfig.getValue(ctx.user().tenant.alias, 'general', 'enabled')) {
        return callback({'code': 401, 'msg': 'Tickets are not enabled for tenant'});
    }

    var validator = new Validator();
    validator.check(opts.creatorId, {'code': 400, 'msg': 'A valid creator ID must be provided'}).isPrincipalId();
    validator.check(opts.publicationId, {'code': 400, 'msg': 'A valid resource ID must be provided'}).isPublicationId();
    validator.check(opts.tenantAlias, {'code': 400, 'msg': 'A valid tenant alias must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        log().error({'code': 400, 'err': validator.getFirstError(), 'resourceId': opts.publicationId}, 'Error while creating new ticket');
        return callback({'code': err.code, 'msg': validator.getFirstError()});
    }

    // Create a ticket ID
    var ticketId = _generateTicketId(opts.tenantAlias);
    TicketsDAO.createTicket(ticketId, opts, function(err, ticket) {
        if (err) {
            log().error({'code': err.code, 'err': err.msg, 'ticketId': ticketId}, 'Error while creating new ticket');
            return callback({'code': err.code, 'msg': err.msg});
        }

        return callback(null, ticket);
    });
};

/**
 * Deletes a specific ticket from the database
 *
 * @param  {Object}     ctx             The current context
 * @param  {String}     ticketId        The id of the ticket that needs to be deleted
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Error object containing error code and error message
 */
var deleteTicket = module.exports.deleteTicket = function(ctx, ticketId, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Only authorized admins are allowed to delete tickets'});
    }

    // Check if the Tickets module is enabled for the tenant
    if (!TicketsConfig.getValue(ctx.user().tenant.alias, 'general', 'enabled')) {
        return callback({'code': 401, 'msg': 'Tickets are not enabled for tenant'});
    }

    var validator = new Validator();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isValidId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Delete a specified ticket
    TicketsDAO.deleteTicket(ticketId, callback);
};

/**
 * Returns a specific ticket
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String}     ticketId            The id of the ticket that needs to be returned
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     The requested ticket
 */
var getTicket = module.exports.getTicket = function(ctx, ticketId, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Only authorized admins are allowed to request tickets'});
    }

    // Check if the Tickets module is enabled for the tenant
    if (!TicketsConfig.getValue(ctx.user().tenant.alias, 'general', 'enabled')) {
        return callback({'code': 401, 'msg': 'Tickets are not enabled for tenant'});
    }

    var validator = new Validator();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isValidId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Return a specified ticket
    TicketsDAO.getTicket(ticketId, callback);
};

/**
 * Returns a collection of tickets
 *
 * @param  {Object}     ctx                 The current context
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket[]}   callback.tickets    Array containing a ticket object for each available ticket for the user
 */
var getTickets = module.exports.getTickets = function(ctx, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Only authorized admins are allowed to request tickets'});
    }

    // Check if the Tickets module is enabled for the tenant
    if (!TicketsConfig.getValue(ctx.user().tenant.alias, 'general', 'enabled')) {
        return callback({'code': 401, 'msg': 'Tickets are not enabled for tenant'});
    }

    // Return a collection of tickets
    TicketsDAO.getTickets(callback);
};

/**
 * Updates a specific ticket
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String}     ticketId            The id of the ticket that needs to be updated
 * @param  {Object}     opts                Object that represents the ticket fields that should be updated
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     The updated ticket
 */
var updateTicket = module.exports.updateTicket = function(ctx, ticketId, opts, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Only authorized admins are allowed to update tickets'});
    }

    // Check if the Tickets module is enabled for the tenant
    if (!TicketsConfig.getValue(ctx.user().tenant.alias, 'general', 'enabled')) {
        return callback({'code': 401, 'msg': 'Tickets are not enabled for tenant'});
    }

    var validator = new Validator();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isValidId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Update and return a specified ticket
    TicketsDAO.updateTicket(ticketId, opts, function(err, ticket) {
        if (err) {
            return callback(err);
        }

        return callback(null, ticket);
    });
};
